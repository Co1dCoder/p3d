// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  THREE.P3DGeometry = (function(_super) {

    __extends(P3DGeometry, _super);

    function P3DGeometry(url, opts, callback) {
      this.opts = opts;
      this.callback = callback;
      this._onP3DLoad = __bind(this._onP3DLoad, this);

      this.loadURL = __bind(this.loadURL, this);

      THREE.Geometry.call(this);
      if (!(opts != null)) {
        this.callback = this.opts;
        this.opts = url;
      }
      if (url != null) {
        this.loadURL(url);
      }
      console.log(this);
    }

    P3DGeometry.prototype.loadURL = function(url) {
      return new P3D(url, this.opts, this._onP3DLoad);
    };

    P3DGeometry.prototype._onP3DLoad = function(p3d) {
      var i,
        _this = this;
      i = 0;
      this.faces = [];
      this.vertices = [];
      p3d._eachFace(function(face) {
        var face3, j, n, normal, v, _i;
        n = face.normals[0];
        normal = new THREE.Vector3(n[0], n[1], n[2]);
        face3 = new THREE.Face3(i++, i++, i++);
        face3.normal.copy(normal);
        face3.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
        for (j = _i = 0; _i <= 2; j = ++_i) {
          v = face.vertices[j];
          _this.vertices.push(new THREE.Vector3(v[0], v[1], v[2]));
        }
        return _this.faces.push(face3);
      });
      this.computeCentroids();
      this.computeFaceNormals();
      this.computeVertexNormals();
      return typeof this.callback === "function" ? this.callback() : void 0;
    };

    return P3DGeometry;

  })(THREE.Geometry);

}).call(this);
